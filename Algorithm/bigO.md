## 빅오 표기법의 종류

### O(1)

처리할 데이터양과 상관없이 항상 일정한 실행시간을 갖는 알고리즘

### O(logN)

처리할 데이터양이 증가할수록 실행시간도 약간씩 증가하는 알고리즘. 실행 시간 증가폭이 logN그래프를 갖기 때문에 급격하게 증가히지는 않음. 일반적으로 효율이 높은 검색 알고리즘의 성능이 여기에 해당함

### O(N)

처리할 데이터양과 실행시간이 비례하여 증가

### O(NlogN)

처리할 데이터양보다 실행시간이 좀 더 빠르게 증가. 일반적으로 효율이 높은 정렬 알고리즘의 성능이 여기에 해당함

### O(N²)

보통 반복문이 2번 중첩된 경우의 알고리즘. 처리할 데이터양이 증가할수록 데이터양의 제곱만큼 실행시간이 소요되므로 좋은 알고리즘이라 볼 수 없음

### O(N³)

반복문이 3번 중첩된 경우의 알고리즘. 마찬가지로 실행시간이 세제곱만큼 증가하므로 좋은 알고리즘이라 볼 수 없음

### O(2ᴺ)

데이터 양의 증가에 따라 2ᴺ만큼 실행시간이 증가하는 알고리즘. 좋은 알고리즘이라 볼 수 없음

## 반복문과 빅오 표기법

> 알고리즘이 어느정도 시간을 소비하는지 빅오표기법으로 나타내면 프로그램을 실행해보기 전이라도 객관적/수학적 성능평가를 할 수 있다.

1. 반복문은 최대 반복 횟수로 계산

```c
for(i = 1; i <= 100; i++)
    sum += 1;
```

1부터 100까지 총 100번을 실행한다. 이렇게 반복문이 한개면 최대 반복횟수를 빅오 표기법으로 표기하면 O(100)이다. 빅오 표기법에서는 **상수인 경우 1**로 표기하므로 위의 반복문은 O(1)이 된다.

100을 N으로 바꾸면 빅오 표기법은 **O(N)** 이 된다.
<br>

2. 중첩 반복문은 중첩문 각각의 최대 반복 횟수를 곱하여 계산

```c
for(i = 1; i < N; i++){
    for(j = 1; j < N; j++){
        k++;
    }
}
```

2개의 for문이 중첩된 경우 반복문 각각의 최대 반복 횟수를 곱해서 빅오 표기법을 계산한다. 첫번째 반복문의 최대 반복 횟수는 N이고 두번째 반복문도 N이므로 N²이다. 따라서 빅오 표기법은 **O(N²)** 이 된다.

만약 중첩반복문이 3개라면 빅오 표기법은 **O(N³)** 이 된다.
<br>

3. 반복문이 떨어져서 2개 있는 경우는 가장 큰 값으로 계산

```c
for(i = 0; i < N; i++){
    sum = sum + i;
}

for(i = 1; i < N; i++){
    for(j = 1; j < N; j++){
        k++;
    }
}
```

첫번째 반복문은 O(N)이고 두번째 반복문은 2개의 for문이 중첩됐으므로 O(N²)이다. 따라서 빅오 표기법은 더 큰 값인 **O(N²)** 이 된다.

<br>

3. 재귀 호출은 풀어서 계산

<br>

4. if/else문은 알고리즘 성능에 영향을 미치지 않음
