## 동기(sync) vs 비동기(async), 블로킹 vs 논블로킹

> [https://siyoon210.tistory.com/147](https://siyoon210.tistory.com/147) 를 참고함

- 동기 vs 비동기 : **처리해야 할 작업들을 어떠한 '흐름'으로 처리할 것인가**에 대한 관점
- 블로킹 vs 논블로킹 : **처리되어야 하는 (하나의) 작업이, 전체적인 작업 '흐름'을 막느냐 안막느냐**에 대한 관점

<br>

## 예시

### 등장인물

```
개발팀장 : 개발팀 작업의 흐름을 조율하고, 개발팀 사원들에게 업무를 지시한다.
사원1, 사원2, 사원3 : 개발팀장이 지시한 일을 수행한다.
```

<br>

### 시나리오1 : 비동기 + 논블로킹

```
1. 개발팀장이 사원1에게 업무A, 사원2에게 업무B, 사원3에게 업무C를 지시 (비동기적 작업 지시)
2. (그리고 바쁜 개발팀장은 개발팀 업무 이외에도 다른 업무를 보기 시작한다.)
3. 사원들은 각자 본인의 맡은 작업을 끝내는대로 개발팀장에게 보고한다. (논블로킹 방식의 작업 처리)
```

- 시나리오1은 일반적인 회사의 작업 '흐름'
- 개발팀장이 사원들에게 업무를 지시하고 사원들은 본인이 맡은 일을 수행한 후에, 개발팀장에게 본인의 작업을 보고하는 방식
- 여기서 개발팀장이 업무들을 `비동기적` 방식으로 처리하고 있음
  - 그리고 사원들은 본인의 작업을 `논블로킹` 방식으로 수행함

<br>

### 시나리오2 : 동기 + 논블로킹

만약에, 개발팀장이 업무를 `동기적`으로 처리한다면

```
1. 개발팀장이 사원1에게 업무A를 지시한다.
2. 개발팀장은 사원1이 업무A를 끝맞칠때 까지 사원1 모니터 뒤에서 기다린다.. .. 끝날 때 까지.. (동기적 작업 지시)
3. 사원1이 업무A를 끝내면 개발팀장이 확인한다.
4. 개발팀장이 사원2에게 업무B를 지시한다.
5. 개발팀장은 사원2가 업무B를 끝맞칠때 까지 사원2 모니터 뒤에서 기다린다.. .. 끝날 때 까지.. (동기적 작업 지시)
6. 사원2가 업무B를 끝내면 개발팀장이 확인한다.
7. ....(사원3은 생략)...
```

- 전체적인 작업의 흐름을 제어하는 개발팀장이 사원에게 업무를 지시하고, 그 사원이 해당 업무를 끝내고 보고 받을 때 까지 기다림
- 사원2와 사원3은 업무만 지시된다면 수행할 준비는 됐지만, 앞선 사원의 일이 끝날 때까지 작업을 진행하지 못함

<br>

### 시나리오3 : 비동기 + 블로킹

만약에, 개발팀장이 업무를 `비동기적`으로 처리하지만, 사원들이 업무를 `블로킹`하게 진행한다면

```
1. 개발팀장이 사원1에게 업무A를 지시하고, 사원2에게 업무B를 지시하고 싶었지만... (비동기적 작업 지시를 하고 싶었지만)
2. 사원1이 개발팀장을 붙잡는다. (블로킹 방식의 작업처리)
3. 그리고 사원1은 자신의 일이 다 끝날때 까지 개발팀장을 놓아주지 않는다.
4. 사원1의 업무가 끝나고 보고받고 나서야, 개발팀장은 사원2에게 업무B를 지시한다.
...(사원2,3 생략)..
```

- 개발팀장이 `비동기적`으로 작업을 진행하고 싶어도, 사원들이 개발팀장을 붙잡는다면 (blocking) 개발팀장은 사원들의 업무가 끝나고 보고 될 때까지 기다리게 됨

<br>

### 시나리오4 : 동기 + 블로킹

```
(시나리오2와 동일하게 진행됨)
```
