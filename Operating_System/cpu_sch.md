# CPU 스케줄링

- 스케줄링(Scheduling) : 여러 프로세스들이 번갈아 사용해야하는 자원이 있을 경우, 주어진 시점에 어떤 프로세스가 이 자원을 사용할 수 있도록 해 줄 것인가를 결정하는 것

## 스케줄링 단계

프로세스 스케쥴링은 수행 단계에 따라 장기, 중기, 단기 스케줄링으로 나뉜다.

### 장기 스케줄링(Long-term Scheduling) or 작업 스케줄링(Job Secheduling)

- 어느 작업을 커널에 등록시켜 프로세스로 만들어 줄 것인가를 결정
- 다중 프로그래밍(Multiprogramming Degree)의 정도를 제어

<br>

### 중기 스케줄링(Medium-term Scheduling)

- 보류상태의 프로세스들 중에서 어느 프로세스에게 메모리를 할당해 줄 것인가를 결정
- 스왑아웃된 프로세스들 중 어떤 프로세스를 다시 스왑인 할것인가를 결정

> 스와핑(Swapping)
>
> > 프로세스가 메모리 공간을 뺏기고 디스크로 나가야하는 것(Swapped Out)<br>
> > 메모리로 돌아오는 것(Swapped In)

<br>

### 단기 스케줄링(Short-term scheduling)

- 준비상태에 있는 프로세스들 중에서 어느 프로세스에게 CPU를 할당할지 결정
- 프로세스 스케줄러 or 디스패처(Dis-pathcher)에 의해 수행됨

<br>

### 스케줄링의 목적, 기준

- 목적 : CPU를 할당받을 프로세스를 잘 골라 실행시켜줌으로써 시스템 성능을 향상
- 시스템 성능 기준
  - 사용자 관점 : 응답시간(프로세스의 요청에 대해 시스템이 최초로 출력을 내줄때까지 걸린 시간)이 지표가 됨
  - 시스템 관점 : 처리량(Throughput, 단위시간에 완료된 프로세스 개수)과 활용도(Utilization, 주어진 시간 동안 특정 자원이 실제 가동된 시간의 비율)

<br>

## 스케줄링 기법

- 비선점(Non-Preemptive) 스케줄링 : 한 프로세스가 CPU를 할당받았을때 CPU를 스스로 반납할때까지 계속 사용하도록 허용
- 선점(Preemptive) 스케줄링 : CPU를 할당받아 실행 중인 프로세스로부터 CPU를 선점(빼앗음)하여 다른 프로세스에 할당하는 방식

### FCFS(First Come First Served) 스케줄링

- 준비 큐에 먼저 도착한 프로세스에게 먼저 CPU를 할당
- CPU를 할당받은 프로세스는 스스로 반납할때까지 CPU를 독점 사용
- 비선점 방식

#### 단점

- 긴 프로세스가 실행될경우 뒤의 프로세스들이 기다려야함 = 대화식 시스템에 적합하지 않음
- 평균 응답시간이 길어짐

<br>

### SJF(Shortest Job First) 스케줄링 or SPN(Shortest Process Next) 스케줄링

- 준비 큐에 기다리고있는 프로세스중 가장짧은(CPU 요구량이 적은) 것을 먼저 실행
- 비선점 방식

#### 단점

- 실행 시간이 긴 프로세스는 CPU를 할당받지 못하여 무한 대기 현상이 발생할 수 있음
  - 방안 : 기다린 시간만큼 우선순위를 높여(에이징, Aging) 실행 가능성을 높여줌
- 실행 전에는 정확히 프로세스들의 크기를 알 수없음에도 스케줄을 해야함
  - 방안 : 프로세스 크기를 실행전 추청해보는 방법 (지수 평균 방법, Exponential Aver-aging)

<br>

### SRT(Shortest Remaining Time) 스케줄링

- 새로운 프로세스가 도착할 때마다 새로운 스케줄링이 이뤄짐
- 선점 방식 : 실행시간이 더 적은 새로운 프로세스가 준비 큐에 들어오면 CPU를 뺏김

#### 단점

- 새로운 프로세스가 도달할 때마다 스케줄링을 다시하기 때문에 CPU burst time(CPU 사용시간)을 측정할 수 없음

<br>

### 라운드 로빈(Round-Robin) 스케줄링

- 각 프로세스는 동일한 크기의 할당 시간(time quantum)을 갖게 됨
- 할당 시간이 지나면 프로세스는 선점당하고 ready queue 의 제일 뒤에 가서 다시 줄을 선다
- CPU 사용시간이 랜덤한 프로세스들이 섞여있을 경우에 효율적
- 선점 방식

#### 주의할 점

- 설정한 시간할당량(time quantum)이 너무 커지면 **FCFS**와 같아짐
- 너무 작아지면 잦은 **context switch** 로 **overhead** 가 발생함

> context swich
>
> > 책상위에서 퍼즐판을 맞추고있는데 다른퍼즐판을 맞추려면 맞추던 퍼즐판을 내려놓고 다른퍼즐판을 올려야 안섞인다. 이렇게 멀티프로세스 환경에서 CPU가 어떤 하나의 프로세스를 실행하고 있는 상태에서 인터럽트 요청에 의해 다음 우선 순위의 프로세스가 실행되어야 할 때, 기존의 프로세스의 상태 또는 레지스터 값(Context)을 저장하고 CPU가 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값(Context)를 교체하는 작업을 Context Switch(Context Switching)라고 한다.

> overhead

> > 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간 · 메모리<br>
> > 예를 들어 A라는 처리를 단순하게 실행한다면 10초 걸리는데, 안전성을 고려하고 부가적인 B라는 처리를 추가한 결과 처리시간이 15초 걸렸다면, 오버헤드는 5초가 됨

<br>

### HRRN(Highest Response Ratio Next) 스케줄링

- SJF, SRT방식의 수행시간이 긴 프로세스의 무한 대기 현상을 방지하기 위한 기법
- 준비 큐에 있는 프로세스들 중 응답률(Response Ratio)이 높은 프로세스에게 우선순위를 줌
- 비선점 방식

> 응답률
>
> > 프로세스의 크기(CPU 요구량)에 대한 대시 시간의 비율

<br>

### Fair-share 스케줄링

- 프로세스들의 특성이나 중요도에 따라 몇개의 그룹으로 나눔
- 특정 그룹에 속한 프로세스의 과도한 CPU사용이 있어도 그 그룹내의 다른 프로세스들에만 불이익을 주고, 다른 그룹으로는 파급되지 않음
