# 세트 사용하기

- 파이썬은 **집합을 표현하는 세트**(set)라는 자료형을 제공한다.
- 집합을 영어로하면 세트, 수학에서 배우는 집합과 같음
- 세트는 합집합, 교집합, 차집합 등의 연산이 가능

## 세트 만들기

- 세트는 `{}`안에 값을 저장하며 각 값은 `,`로 구분해줌
- `세트 = {값1, 값2, 값3}`
- 세트를 출력해보면 매번 **요소의 순서가 다르게 나온다.**
- 세트의 요소는 **중복될 수 없다.**

```py
>>> name = {'Apple', 'Mac', 'Window', 'Linux', 'Ubuntu'}
>>> name
{'Ubuntu', 'Apple', 'Mac', 'Linux', 'Window'}
```

<br>

- 세트는 리스트/튜플/딕셔너리와 달리 `[]`로 특정 요소만 출력할 수는 없다.

```py
>>> name = {'Apple', 'Mac', 'Window', 'Linux', 'Ubuntu'}

>>> print(name[0])
# Traceback (most recent call last):
#   File "<pyshell#148>", line 1, in <module>
#     print(name[0])
# TypeError: 'set' object is not subscriptable
```

### 세트에 특정 값이 있는지 확인하기

- 리스트/튜플/딕셔너리와 같이 `in`연산자를 사용하면 특정 값을 확인할 수 있다.
- `값 in 세트` , `값 not in 세트`

```py
>>> name = {'Apple', 'Mac', 'Window', 'Linux', 'Ubuntu'}
>>> 'Mac' in name
True
>>> 'XXX' in name
False
```

### set을 이용하여 세트 만들기

- `set(반복가능한객체)`

```py
>>> y = set('appppple')
>>> y
{'a', 'e', 'p', 'l'}

>>> z = set(range(5))
>>> z
{0, 1, 2, 3, 4}
```

- `type`을 이용하면 자료형의 종류를 알 수 있다.

```py
>>> k = {}
>>> type(k)
<class 'dict'>

>>> k = set()
>>> type(k)
<class 'set'>
```

## 집합 연산 사용하기

> 집합 연산은 파이썬의 산술연산자와 논리연산자를 활용한다.

### 합집합

- `|`연산자는 **합집합**(union)을 구하며 `OR`연산자 `|`를 사용한다.
- `세트 1 | 세트 2`
- `set.union(세트1, 세트2)`

```py
>>> a = {1,2,3,4}
>>> b = {3,4,5,6}

>>> a | b
{1, 2, 3, 4, 5, 6}

>>> set.union(a, b)
{1, 2, 3, 4, 5, 6}
```

### 교집합

- `&`연산자는 **교집합**(intersection)을 구하며 `AND`연산자 `&`를 사용한다.
- `세트 1 & 세트 2`
- `set.intersection(a, b)`

```py
>>> a = {1,2,3,4}
>>> b = {3,4,5,6}

>>> a & b
{3, 4}

>>> set.intersection(a,b)
{3, 4}
```

### 차집합

- `-`연산자는 **차집합**(difference)를 구하며 뺄셈 연산자 `-`를 사용한다.
- `세트 1 - 세트 2`
- `set.difference(a, b)`

```py
>>> a = {1,2,3,4}
>>> b = {3,4,5,6}

>>> a-b
{1, 2}
>>> set.difference(a,b)
{1, 2}
```

### 대칭차집합

- `^`연산자는 **대칭차집합**(symmetric difference)을 구하며 `XOR`연산자 `^`를 사용한다.
- XOR은 서로 다르면 참이다. 집합에서는 **두 집합중 겹치지 않는 요소**만 포함한다.
- `세트 1 ^ 세트 2`
- `set.symmetric_difference(a, b)`

```py
>>> a = {1,2,3,4}
>>> b = {3,4,5,6}

>>> a ^ b
{1, 2, 5, 6}
>>> set.symmetric_difference(a,b)
{1, 2, 5, 6}
```

## 집합 연산 후 할당 연산자 사용하기

- 세트 자료형에 `|, &, -, ^` 연산자와 할당 연산자 `=`을 함께 사용하면 집합 연산의 결과를 다시 변수에 저장(할당)한다.

<br>

1. `|=`는 현재 세트에 다른 세트를 더하며 `update`메서드와 같다.

```py
>>> a = {1,2,3,4}
>>> a |= {5}
>>> a
{1, 2, 3, 4, 5}

>>> a = {1,2,3,4}
>>> a.update({5})
>>> a
{1, 2, 3, 4, 5}
```

2. `&=`는 현재 세트와 다른 세트 중 겹치는 요소만 현재 세트에 저장하며 `intersection_update`메서드와 같다.

```py
>>> a = {1,2,3,4}
>>> a &= {0,1,2,3,4,5,6}
>>> a
{1, 2, 3, 4}
```

3. `-=`는 현재 세트에서 다른세트를 뺀다. `difference_update`메서드와 같다.

```py
>>> a = {1,2,3,4}
>>> a -= {3}
>>> a
{1, 2, 4}
```

4. `^=`는 현재 세트와 다른 세트 중에서 겹치지 않는 요소만 세트에 저장한다. `symmetric_difference_update`메서드와 같다.

```py
>>> a = {1,2,3,4}
>>> a ^= {3,4,5,6}
>>> a
{1, 2, 5, 6}
```

## 부분집합과 상위집합 확인하기

- 세트는 부분집합, 진부분집합, 상위집합, 진상위집합과 같이 속하는 관계를 표현할 수도 있다.
- 현재 세트가 다른 세트의 (진)부분집합 또는 (진)상위집합인지 확인할 때는 세트 자료형에 부등호와 등호를 사용한다.

1. `<=`는 현재 세트가 다른 세트의 부분집합(subset)인지 확인하며 `issubset`메서드와 같다.

```py
>>> a = {1,2,3,4}
>>> a <= {1,2,3,4}
True
>>> a.issubset({0,1,2,3,4,5})
True
```

2. `<`는 현재 세트가 다른세트의 진 부분집합(proper subset)인지 확인하며 메서드는 없다. (진부분집합이란 부분집합중 같은 것을 뺀 것)

```py
>>> a = {1,2,3,4}

>>> a < {1,2,3,4}
False
>>> a < {1,2,3,4,5}
True
```

3. `>=`는 현재 세트가 다른 세트의 상위집합(superset)인지 확인하며 `issuperset`메서드와 같다.

```py
>>> a = {1,2,3,4}
>>> a >= {1,2}
True
```

4. `>`는 현재 세트가 다른 세트의 진상위집합(proper superset)인지 확인하며 메서드는 없다.

(`코드생략`)

## 세트가 같은지 다른지 확인하기

- 세트는 `==` 연산자를 사용하여 서로 같은지 확인할 수 있다.
- 세트는 요소의 순서가 정해져 있지 않으므로 `==`로 비교했을 때 각 요소만 같으면 참이다.
- `!=` 연산자는 세트가 다른지 확인한다.

```py
>>> a = {1,2,3,4}

>>> a == {4,2,3,1}
True

>>> a != {1,2,3}
True
```

## 세트가 겹치지 않는지 확인하기

- `disjoint`는 현재 세트가 다른 세트와 겹치지 않는지 확인한다.

```py
>>> a = {1,2,3,4}

>>> a.isdisjoint({5,6,7,8})     # 겹치는 요소없음
True
>>> a.isdisjoint({3,4,5,6})     # 3, 4가 겹침
False
```

<br>

## 세트 조작하기

### 세트에 요소 추가하기

- `add(요소)`는 세트에 요소를 추가한다.

```py
>>> a = {1,2,3,4}
>>> a.add(5)
>>> a
{1, 2, 3, 4, 5}
```

### 세트에서 특정 요소 삭제하기

- `remove(요소)`는 세트에서 특정 요소를 삭제하고 요소가 없으면 에러를 발생시킨다.

```py
>>> a = {1,2,3,4}
>>> a.remove(3)
>>> a
{1, 2, 4}

>>> a.remove(77)
# Traceback (most recent call last):
#   File "<pyshell#222>", line 1, in <module>
#     a.remove(77)
# KeyError: 77
```

- `discard(요소)`는 세트에서 특정 요소를 삭제하고 요소가 없으면 그냥 넘어간다.

```py
>>> a = {1,2,3,4}
>>> a.discard(999)
>>> a
{1, 2, 3, 4}
```

### 세트에서 임의의 요소 삭제하기

- `pop()`은 세트에서 **임의의 요소**를 삭제하고 해당 요소를 반환한다.
- 만약 요소가 없으면 에러를 발생시킨다.

```py
>>> a = {1,2,3}
>>> a.pop()
1
>>> a.pop()
2
>>> a.pop()
3
>>> a.pop()
# Traceback (most recent call last):
#   File "<pyshell#227>", line 1, in <module>
#     a.pop()
# KeyError: 'pop from an empty set'
```

### 세트의 모든 요소 삭제하기

- `clear()`는 세트에서 모든 요소를 삭제한다.

```py
>>> a = {1,2,3,4}
>>> a.clear()
>>> a
set()
```

### 세트의 길이 구하기

- `len(세트)`는 세트의 요소 개수(길이)를 구함

```py
>>> a = {1,2,3,4}
>>> len(a)
4
```

## 세트의 할당과 복사

- 세트를 만들고 다른 변수에 할당하면 세트는 두개가 아니라 실제로는 한 개다.
- 변수 이름만 다를 뿐 세트 a와 b는 같은 객체다.
- a와 b는 같으므로 b에 요소를 추가하면 a와b 모두 반영된다.

```py
>>> a = {1,2,3,4}
>>> b = a

>>> a is b
True

>>> b.add(5)
>>> a
{1, 2, 3, 4, 5}
>>> b
{1, 2, 3, 4, 5}
```

<br>

- 세트 a와 b를 완전히 두개로 만드려면 `copy`메서드로 모든 요소를 복사한다.
- 이러면 a와 b는 별개이므로 한쪽 값을 변경해도 다른세트에 영향이 없다.

```py
>>> a = {1,2,3,4}
>>> b = a.copy()

>>> a is b
False
>>> a == b
True

>>> a.add(5)
>>> a
{1, 2, 3, 4, 5}
>>> b
{1, 2, 3, 4}
```

## 반복문으로 세트의 요소를 모두 출력하기

- 간단하게 `for in` 뒤에 세트만 지정하면 된다.

```py
for 변수 in 세트:
    반복할 코드
```

```py
>>> a = {1,2,3,4}
>>> for i in a:
    	print(i)

# 1
# 2
# 3
# 4
```

- 세트의 요소는 순서가 없으므로 출력할때마다 순서가 달라진다.
- 숫자로만 이루어진 세트는 순서대로 출력된다.

```py
>>> x = {'a', 'd', 'o', 'p'}
>>> for i in x:
    	print(i)

# d
# a
# p
# o
```

## 세트 표현식 사용하기

- 세트는 `for` 반복문과 `if`조건문을 사용하여 세트를 생성할 수 있다.
- `[식 for 변수 in 반복가능객체]`
- `set[식 for 변수 in 반복가능객체]`

```py
>>> a = {i for i in 'apple'}
>>> a
{'a', 'e', 'p', 'l'}
```

문자열에서 중복된 문자는 세트에 포함되지 않는다.

### 세트 표현식에 if 조건문 사용하기

```py
>>> a = {i for i in 'applemac' if i not in 'apple'}
>>> a
{'m', 'c'}
```
