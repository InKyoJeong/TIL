## 객체지향 프로그래밍 (Object-Oriented Programming)

> 로직을 상태와 행동(변수와 메소드)로 나누고 연관된 것들끼리 그룹핑한 것을 객체라 하고 이를 조립해 프로그래밍을 하는 것.

### 객체지향의 여러 가지 특성들

- 부품화 : 프로그램의 로직들을 기능별로 나눠 부품화하는 것
- 은닉화, 캡슐화 : 로직을 온전히 부품화하기 위해 내부동작법은 숨기고 사용법만 노출하는 것
- 인터페이스 : 부품들간의 접점에서의 규칙, 약속

#### 객체지향은 코드의 재활용성을 높인다.

- 자주 사용되는 로직을 라이브러리로 만들어두면 계속해서 사용할 수 있으며 그 신뢰성을 확보 할 수 있다. 또한 라이브러리를 각종 예외상황에 맞게 잘 만들어두면 개발자가 사소한 실수를 하더라도 그 에러를 컴파일 단계에서 잡아낼 수 있으므로 버그 발생이 줄어든다.

- 내부적으로 어떻게 동작하는지 몰라도 개발자는 라이브러리가 제공하는 기능들을 사용할 수 있기 때문에 생산성이 높아지게 된다. 객체 단위로 코드가 나눠져 작성되기 때문에 디버깅이 쉽고 유지보수에 용이하다.

- 데이터 모델링을 할 때 객체와 매핑하는 것이 수월하기 때문에 요구사항을 보다 명확하게 파악하여 프로그래밍 할 수 있다.

### 객체 지향적 설계 원칙

1. SRP(Single Responsibility Principle) : 단일 책임 원칙<br>클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단 하나의 이유이어야 한다.
2. OCP(Open-Closed Principle) : 개방-폐쇄 원칙<br>확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
3. LSP(Liskov Substitution Principle) : 리스코프 치환 원칙<br>상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
4. ISP(Interface Segregation Principle) : 인터페이스 분리 원칙<br>인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
5. DIP(Dependency Inversion Principle) : 의존 역전 원칙<br>고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.

## 생성자와 new

> 객체지향 프로그래밍을 간단히 말하면 서로연관된 변수와 서로연관된 메소드를 하나의 객체라는 그릇에 넣는것이다. 서로연관되지않은 것들은 별도의 객체에 분리시키는 것이다. (연관된것들을 그룹핑한다)

`객체`란 서로 연관된 변수와 함수를 그룹핑한 그릇이라고 할 수 있다. 객체 내의 변수를 `프로퍼티(property)`, 함수를 `메소드(method)`라고 부른다.

```js
const person1 = {
  name: "John",
  introduce: function() {
    return "My name is " + this.name;
  }
};
const person2 = {
  name: "Mary",
  introduce: function() {
    return "My name is " + this.name;
  }
};
```

객체를 여러개 만든다고 하면 `introduce`라는 메소드를 정의하는 부분이 중복 되고 있다. 이런 메소드의 동작 방법을 바꾼다고 하면 그 객체들이 가지고 있는 메소드 전체를 찾아서 똑같이 바꿔야하는 이슈가 생긴다. (= 중복이 생긴다) 객체의 구조를 재활용할 수 있는 방법이 필요하다. 이 중복을 해결하기 위한 것이 `생성자, new`이다.

### 생성자

> 생성자(constructor)는 객체를 만드는 역할을 하는 함수이다. 자바스크립트에서 함수는 재사용 가능한 로직의 묶음이 아니라 객체를 만드는 창조자라고 할 수 있다.

```js
function Person() {}
const p = new Person();

p; // Person{}
```

함수에 `new`를 붙이면 그 리턴값은 객체가 된다.

```js
function Person(name) {
  this.name = name;
  this.introduce = function() {
    return "My name is " + this.name;
  };
}
const p1 = new Person("John");

console.log(p1); // -> Person {name: "John", introduce: ƒ}
```

생성자 내에서 이 객체의 프로퍼티를 정의하고 있다. 이렇게 생성자는 객체를 생성하고 **초기화**하는 역할을 한다. 생성자 함수는 일반함수와 구분하기 위해 첫글자를 대문자로 표시한다.

## 전역 객체

전역객체는 특수한 객체다. 모든 객체는 이 전역객체의 프로퍼티다.

```js
function func() {
  alert("Hello?");
}

func();
window.func();
```

`func();`와 `window.func();`는 모두 실행이 된다. 모든 전역변수와 함수는 사실 `window` 객체의 프로퍼티다. 객체를 명시하지 않으면 암시적으로 window의 프로퍼티로 간주된다.

전역객체의 이름도 호스트환경에 따라서 다른데, 웹브라우저에서 전역객체는 `window`이지만 `node.js`에서는 `global`이다.
