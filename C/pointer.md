## 포인터

> 메모리의 주소를 가지고 있는 변수

변수는 자료들을 저장하는 역할을 하므로 메모리(memory)에 만들어진다. 메모리는 각 바이트마다 고유한 주소를 가지고 있다. 메모리의 첫 번째 바이트의 주소는 0, 두번째 바이트의 주소는 1, 이런식으로 각각의 바이트마다 1씩 증가한다.

변수가 메모리상의 어디에 배치되었는지 변수의 주소를 알 수 있다. `주소연산자` `&`는 변수의 이름을 받아서 변수의 주소를 반환한다.

```c
#include <stdio.h>

int main(){
    int i = 10;
    char c = 49;
    float f = 12.3;

    printf("i의 주소: %d\n", &i);
    printf("c의 주소: %d\n", &c);
    printf("f의 주소: %d\n", &f);

    return 0;
}

//i의 주소: -272632440
//c의 주소: -272632441
//f의 주소: -272632448
```

### 포인터 선언과 초기화

포인터를 선언할때는 자료형을 먼저 쓰고 `*`를 붙인후 포인터의 이름을 쓴다. 여기서 `*`기호는 곱셈과 관련이 없으며 `...을 가리키는` 이라 해석하면 편하다.

```
int *p;
```

```
int *p;
int i = 10;
p = &i;
```

변수 i의 주소가 4였다고 가정하고 p = &i연산을 실행하면 변수 i의 주소인 4가 p에 대입된다.
이상태를 포인터 변수 p가 변수 i를 가리키게 된다고 말한다.

### 포인터를 통한 간접 참조

포인터 p가 가리키는 주소에 저장된 내용을 가져오려면 p앞에 *기호를 붙여 *p하면 된다. 이것을 포인터를 통하여 메모리를 **간접참조**한다고 한다. 만약 p가 변수 i를 가리킨다고 하면 \*p는 변수 i의 값과 같다.

```c
#include <stdio.h>
int main(){
    int *p;
    int i = 10;
    p = &i;
    printf("%d", *p);
    return 0;
}
// 10
```

### 포인터를 통해 변수를 변경할 수 있다

```c
#include <stdio.h>

int main(){
    int i = 10;
    int *p;

    p = &i;

    printf("i의 값 = %d\n", i);

    *p = 20;    // *p, 즉 변수 i에 20을 대입한다.
    printf("i의 값 = %d\n", i);
    return 0;
}
//i의 값 = 10
//i의 값 = 20
```

### 포인터 연산

포인터에 대해서는 덧셈과 뺄셈만 허용된다. int형 포인터를 증가시키면 int형의 크기인 4바이트만큼 증가한다. char형 포인터를 증가시키면 char형 크기인 1바이트 만큼 포인터 값이 증가한다. --연산자를 이용해 감소시킬때도 마찬가지. +나 -연산자도 마찬가지.

### 포인터는 왜 사용할까

포인터를 사용할때의 몇 가지 장점이 있다.

- 포인터를 이용하면 `연결리스트`나 `이진트리` 등의 향상된 자료구조를 만들 수 있다. 연결리스트는 포인터를 사용하여 메모리에 흩어져있는 데이터들을 연결하는 자료구조이다. 포인터가 데이터가 저장된 곳을 가리킬 수 있기 때문에 포인터들로 연결된 구조를 생각해 볼 수 있다.

- 데이터의 복수를 피하고 여러 코드들이 데이터를 공유하면서 작업하고자 할 때 포인터를 사용하게 된다. 예를 들어 누군가 블랙홀에 대해 질문했을때 백과사전 전체를 복사해 주는 것보다 백과사전이 있는 곳을 알려주고 520페이지를 보라고 알려주는 편이 효율적일 수 있다.

## 포인터와 함수

### 함수에 인수를 전달하는법

> 함수가 외부로부터 데이터를 전달받는 방법은 크게 두가지

- 값에의한 호출 : 복사본이 전달된다.
- 참조에의한 호출 : 원본이 전달된다.

```c
int main (void){
    int a = 2;
    int b = 3;
    sum = add(a, b);        //인수(전달하는 값)
    ...
}
```

```c
int add(int x, int y){      //매개변수
    ...

}
```

C언어에서는 기본적으로 **값에 의한 호출**만을 지원함. `add()`를 호출할 때, 인수로 a와 b를 전달하고 있지만 실제 전달되는 것은 변수 a,b가 아니라 **변수 a,b의 값**이다. 이 값이 매개변수 x와 y로 복사된다. 따라서 add()함수 안에서 x, y를 변경해도 변수 a와 b값에는 전혀 영향을 끼치지 않는다.

C언어에서 참조에 의한 호출은 포인터를 이용해서 간접 구현이 가능하다.

### 값에 의한 전달

```c
#include <stdio.h>
void moving(int xpos, int ypos);

int main(void){
    int x = 10;
    int y = 20;

    printf("현재의 위치 (%d,%d)\n", x, y);
    moving(x,y);
    printf("현재의 위치 (%d,%d)\n", x, y);
    return 0;
}
void moving(int xpos, int ypos)     // 변수의 값이 전달된다.
{
    xpos = xpos + 1;
    ypos = ypos + 1;
}
//현재의 위치 (10,20)
//현재의 위치 (10,20)
```

위치가 변경되지 않은 이유는 **값에 의한 호출** 이기 때문에 변수의 값이 복사될 뿐, 원본은 변경되지 않은 것이다.

### 참조에 의한 전달

```c
#include <stdio.h>
void moving(int *xpos, int *ypos);

int main(void){
    int x = 10;
    int y = 20;

    printf("현재의 위치 (%d,%d)\n", x, y);
    moving(&x,&y);
    printf("현재의 위치 (%d,%d)\n", x, y);
    return 0;
}
void moving(int *xpos, int *ypos)       // 변수의 주소가 전달된다.
{
    *xpos = *xpos + 1;
    *ypos = *ypos + 1;
}
//현재의 위치 (10,20)
//현재의 위치 (11,21)
```

변수의 주소를 전달해서 주소를 참조해서 원래 변수의 값이 변경되도록 한다.

### 인수를 변경하지 못하게 하기

함수에 따라 포인터를 통해 인수를 변경하고 싶지 않은 경우도 있다. 예를 들어 포인터를 통해 값을 받고 단순히 출력만 하는 경우도 있다. 매개변수 앞에 `const`를 붙이면 함수 안에서 인수를 변경할 수 없다.

```c
#include <stdio.h>
void display(const int *xpos, const int *ypos);
void moving(int *xpos, int *ypos);

int main(void){
    int x = 10;
    int y = 20;

    display(&x, &y);
    moving(&x, &y);
    display(&x, &y);

    return 0;
}
void display(const int *xpos, const int *ypos){
    printf("현재위치 : (%d, %d)\n", *xpos, *ypos);
}
void moving(int *xpos, int *ypos)
{
    *xpos = *xpos + 1;
    *ypos = *ypos + 1;
}
//현재위치 : (10, 20)
//현재위치 : (11, 21)
```

### scanf()

**참조에 의한 호출**을 사용하는 대표적인 예가 `scanf`이다. 변수 이름만 전달하면 `scanf()`는 변수에 값을 저장할 수 없다. C에서는 기본적인 인수 전달 방식이 **값에 의한 호출**이기 때문이다. 따라서 변수의 주소를 `scanf()`에 보내 사용자로부터 받은 값이 변수에 저장되도록 해야한다.

## 포인터와 배열

```c
#include <stdio.h>
int main(void){
    int a[] = {10, 20, 30, 40};

    printf("&a[0] = %d\n", &a[0]);
    printf("&a[1] = %d\n", &a[1]);
    printf("&a[2] = %d\n", &a[2]);

    printf("a = %d\n", a);

    return 0;
}
//&a[0] = -272632464
//&a[1] = -272632460
//&a[2] = -272632456
//a = -272632464
```

배열요소의 주소를 출력해보면 요소들이 메모리에서 연속된 공간을 차지하고 있음을 알 수 있다. a가 `int`형 배열이므로 각 요소들이 차지하는 메모리 공간은 4바이트이다. 여기서 배열의 이름을 출력하면 배열의 첫번째 요소의 주소와 같다.

따라서 배열 이름은 배열의 첫 번째 요소를 가리키는 포인터처럼 사용할 수 있다.
